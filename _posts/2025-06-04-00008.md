---

title: "[MIT6.034] 8.제약 만족 문제와 자원 스케줄링 (Constraint Satisfaction & Resource Scheduling)"
date: 2025-06-04 19:00:00 +0900
categories: [AI, AI-Lecture]
tags: [MIT-6.034]
math: true
---
 
**🗺️ MIT AI 강의 8 - 제약 만족 문제(Constraint Satisfaction Problem, CSP)와 자원 할당 문제(Resource Scheduling)**

---

## 🎨 지도 색칠 문제와 제약 만족

### 문제:

* 지도 내 모든 주(State)를 **인접한 주와 다른 색**으로 칠해야 함 (예: 빨강, 초록, 파랑, 노랑)
* 단순한 DFS(깊이 우선 탐색)은 **후행 제약에 의해 많은 백트래킹** 발생

### Texas 사례:

* 주변 4개 주 먼저 칠한 후 Texas를 마지막에 칠하면 선택 가능한 색이 남지 않게 됨
* 해당 제약은 사실상 **네 번째 선택 지점에서 이미 발생했음** → 탐색 낭비

> 📌 탐색 순서, 색 순서가 중요하며 제약을 미리 파악해야 비효율 방지 가능

---

## 🔁 제약 전파로 해결

### 변수/값/도메인/제약 정의:

* **변수(variable)**: 주 (예: Texas)
* **값(value)**: 색 (예: R, G, B, Y)
* **도메인(domain)**: 선택 가능한 값 집합
* **제약(constraint)**: 인접한 주는 같은 색을 가질 수 없음

### 제약 전파 알고리즘 개요:

1. 색을 할당할 때마다 그 영향을 **이웃 변수의 도메인에 반영**
2. 도메인에서 어떤 값도 유효하지 않게 되면 **백트래킹**

```text
for each assignment:
    for each neighbor v:
        for each value x in domain(v):
            if no compatible value in neighbor's domain:
                remove x from domain(v)
            if domain(v) becomes empty:
                backtrack
```

---

## 🧪 다양한 고려 수준별 탐색 비교

### 탐색 전략별 효과 비교:

| 전략                                              | 설명                                                                                                                                                                          | 장점                        | 단점                         |
| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------- | ---------------------------- |
| **1. 아무것도 고려하지 않음**                     | 제약을 전혀 고려하지 않고 가능한 값 중 하나를 무작위로 할당. <br> 그냥 넣고 보자는 식.                                                                                        | ✅ 매우 빠름                 | ❌ 충돌 다수 (실패율 높음)    |
| **2. 전체 상태 고려**                             | 전체 변수의 현재 상태와 미래 가능성까지 전부 탐색. <br> 일종의 완전 탐색 방식.                                                                                                | ✅ 정확함                    | ❌ 매우 느림, 계산량 폭증     |
| **3. 현재 노드만 고려**                           | 지금 이 노드에서 가능한 값들만 보고 선택. <br> 주변 상황은 무시.                                                                                                              | ⚠️ 조금 개선됨               | ❌ 미래 충돌 가능성 큼        |
| **4. 이웃 노드까지 고려**                         | 인접 노드들과 충돌이 나는지 확인 후 가능한 값만 선택. <br> 1~3보다 현명한 전략.                                                                                               | ✅ 충돌 줄어듬               | ⚠️ dead end 발생 가능성 존재  |
| **5. 이웃 + 도메인이 1개로 줄어든 변수까지 전파** | 이웃 노드뿐 아니라, <br> 그 이웃 중 가능한 값이 **1개로 확정된 변수**까지 함께 고려. <br> <br> 이 과정을 통해 앞으로의 충돌도 미리 예방. (→ **제약 전파 / forward checking**) | ✅ 매우 효율적 (가장 안정적) | ⚠️ 구현이 다소 복잡할 수 있음 |







---

## 🧭 변수 선택 전략: Most Constrained First

* **가장 제약이 많은 변수(인접 노드 많음)**부터 먼저 할당
* 반례: Maine (인접 1개)부터 시작 → DFS 비효율 발생
* 실험 결과: **가장 제약 많은 노드부터 시작하는 것이 훨씬 효율적**

---

## ✈️ 자원 스케줄링 예제: 항공편

### Jet Green 예시

* 최소 항공기로 주어진 일정 소화하기
* 항공편:

  * F1: Boston → JFK
  * F2: JFK → Boston
  * F3: Boston → JFK
  * F4: JFK → Boston
  * F5: Boston → LAX

### 제약들:

* 하나의 항공기는 **동시에 두 비행 수행 불가**
* **최소 지상 대기 시간** 필요
* 특정 순서 내 착륙 및 이륙 고려 필요

> ✅ 완전히 동일한 문제 구조: **항공편 = 변수, 항공기 = 색, 시간 겹침 = 인접성 제약**

---

## 🎯 최소 자원 계산법: Binary Search

* 최댓값: 항공편 수 (모든 항공편에 다른 항공기 할당)
* 최솟값: 1 (하나의 항공기로 모든 스케줄 소화)

### 방법:

* 작은 수부터 할당 시도 → 실패 시 바로 확인 가능 (under-constrained)
* 큰 수부터 할당 시도 → 바로 성공 확인 (over-constrained)
* 사이 영역을 **이진 탐색 방식으로 좁혀나감** → 빠른 수렴

---

## ✅ 정리

* 제약 만족 문제(CSP)는 다양한 문제에 적용 가능 (지도 색칠, 비전 인식, 자원 스케줄링 등)
* 핵심 기법:

  * DFS 기반 탐색
  * 도메인 축소 및 제약 전파
  * Most-constrained-first 변수 선택
  * Domain이 1개로 줄어들었을 때만 전파
* 자원 문제에도 동일한 구조 적용 가능하며, 최적 자원 수 계산에 **under/over 접근**이 효과적
