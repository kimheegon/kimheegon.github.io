---
title: "[MIT6.034] 5.Search: Shortest Path and A* Algorithm"
date: 2025-06-03 20:30:00 +0900
categories: [AI. AI-Lecture]
tags: [MIT-6.034]
math: true
---

**📘 MIT AI 강의 5 - 탐색: 최단 경로와 A* 알고리즘 (Shortest Path and A* Algorithm) (Patrick Winston)**

---

## 🚗 도입 - Route 66과 선택의 문제

* Route 66은 시카고와 LA를 잇는 과거의 최단 고속도로였으며, 선택(choice)의 문제를 설명하기 위한 사례로 제시됨
* Eisenhower는 독일의 아우토반(Autobahn)에서 착안하여 미국 내 고속도로 시스템을 구축함
* 탐색(search)은 지도(map)가 아닌 **선택(choice)** 의 문제임

---

## 🧭 탐색 문제와 시각적 휴리스틱

### 🎯 문제 설정

* 출발점 S에서 도착점 G까지 **최단 경로(shortest path)** 를 찾는 것이 목표
* 예시 지도와 추상적 그래프를 기반으로 탐색 전략을 비교함

### 🧠 휴리스틱 거리 (Heuristic Distance)

* 노드 간 실제 도로가 없어도 직선 거리(as-the-crow-flies)를 기준으로 남은 거리 추정
* 예: D가 G에 가까워 보이지만 실제로는 막다른 길(dead end)일 수 있음

---

## 🧱 브랜치 앤 바운드 (Branch and Bound)

* 현재까지의 누적 거리(g(n))가 가장 짧은 경로부터 확장
* 목표에 도달했더라도, 다른 모든 경로가 더 긴지 확인해야 함

### 예시 (S → A → D → G):

* Juana가 제시한 최단 경로로, 거리 총합은 11
* 다른 경로들(S→B→A, S→B→C 등)도 확장하며 Juana의 해답 검증

---

## ✂️ 확장 리스트 (Extended List)

* 이미 어떤 노드를 **더 짧은 경로로 한 번 확장했다면**, 이후 해당 노드를 포함하는 경로는 확장하지 않음
* 이는 A\*가 **같은 노드를 여러 번 확장하는 것을 방지**하여 중복 계산을 막는 기법

### 효과:

* 중복 확장을 피함으로써 탐색 효율 증가
* 예시: 확장 수 835 → 38로 감소 (강의 예제 기준)

> 📌 확장 리스트는 "이전에 더 짧은 경로로 도달했던 노드를 다시 확장하지 않는다"는 규칙을 따름

---

## 🧮 휴리스틱 기반 탐색

### 🎯 Admissible Heuristic (허용 가능한 휴리스틱)

* **정의**: 어떤 노드 x에 대해, 휴리스틱 추정값이 실제 거리보다 작거나 같을 때

$$
h(x) \leq h^*(x) \quad (h^*는 실제 목표까지 거리)
$$

* 즉, 낙관적 추정만 허용됨. 실제보다 과대평가(overestimate)하면 안 됨.

### 예시:

* 실제 거리 A→G = 7일 때, h(A) = 5는 허용됨 → admissible
* h(A) = 9는 과대추정 → admissible 아님

### 평가 함수:

$$
f(n) = g(n) + h(n)
$$

* g(n): 시작점부터 현재 노드까지 누적 거리
* h(n): 현재 노드부터 목표까지의 추정 거리

---

## 🌟 A\* 알고리즘 (A Star Algorithm)

* **브랜치 앤 바운드 + 확장 리스트 + admissible 휴리스틱**의 결합
* 가장 f(n)이 낮은 경로부터 확장 → 효율성과 최적성 보장

### 성능:

* 단독 알고리즘보다 훨씬 적은 확장으로 목표 도달 (예: 확장 수 27)

---

## ⚠️ Admissible만으로는 부족할 수 있음

### 사례:

* 그래프:

  * S → A → C → G (거리: 1 + 1 + 10 = 12)
  * S → B → C → G (거리: 1 + 1 + 10 = 12)

### 휴리스틱 설정:

* h(A) = 100, h(B) = 0, h(C) = 0
* h(A)는 실제보다 과대추정처럼 보이지만 전체 경로는 101이므로 admissible

### 문제:

* A는 f(A) = 1 (g) + 100 (h) = 101
* B는 f(B) = 1 (g) + 0 (h) = 1 → 먼저 확장됨
* 이후 C가 확장 리스트에 추가됨
* 나중에 A → C로 도달해도 C는 이미 확장된 상태라 무시됨
* **최단 경로를 놓침**

---

## 📐 Consistency (일관성)의 필요성

* **정의**:

$$
|h(x) - h(y)| \leq d(x, y)
$$

* 휴리스틱 차이가 실제 거리보다 크면 안 됨

### 왜 필요한가?

* Consistency가 보장되면, 어떤 노드에 대한 **더 짧은 경로가 나중에라도 발견되면 반드시 사용됨**
* 확장 리스트가 있어도 **최적 경로를 놓치지 않게 됨**

### 위 사례 분석:

* h(A)=100, h(C)=0 → |100 - 0| = 100 > d(A, C)=1 → **Consistency 위반**
* → admissible은 만족하지만 consistent는 아님 → **A\*** 실패 가능

### 📌 정리된 정리 (정리의 정리):

* **Consistency가 보장되면** 확장 리스트 사용해도 A\*는 **최단 경로를 항상 찾는다**
* 이는 A\* 알고리즘의 **최적성(optimality)** 을 수학적으로 보장하는 핵심 조건임

---

## ✅ 정리

* A\*는 다음 세 가지 구성 요소로 이루어짐:

  1. 누적 거리(g(n))
  2. 낙관적 휴리스틱(h(n)) → admissible
  3. 중복 방지 확장 리스트
* 휴리스틱이 **admissible** 하더라도 **consistent** 하지 않으면 최단 경로를 놓칠 수 있음
* Consistency는 A\* 알고리즘의 **최적성 보장을 위한 충분조건**임
* 따라서 지도 기반이 아닌 일반 그래프에서도 **Consistency가 반드시 필요함**

