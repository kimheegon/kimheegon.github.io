---
title: "[MIT6.034] 5.Search: Shortest Path and A* Algorithm"
date: 2025-06-03 20:30:00 +0900
categories: [AI. AI-Lecture]
tags: [MIT-6.034]
math: true
---

**📘 MIT AI 강의 5 - 탐색: 최단 경로와 A* 알고리즘 (Shortest Path and A* Algorithm) (Patrick Winston)**

---

## 🛣️ **Route 66과 최단 경로 문제 (Shortest Path Problem)**

* Route 66은 시카고(Chicago)와 LA(Los Angeles)를 잇는 과거의 주요 도로
* 미국을 횡단하려는 사람들이 가장 짧은 경로로 이용함
* 현재는 **아이젠하워(Eisenhower)** 대통령 시절 구축된 \*\*인터스테이트 고속도로 시스템(Interstate Highway System)\*\*으로 대체됨

  * 이유: 독일군이 **아우토반(Autobahn)** 덕분에 철도 파괴에도 신속히 병력을 이동시킨 것을 보고 착안
* 교수는 Caterpillar Tractor Company 본사가 있는 **일리노이(East Peoria, Illinois)** 출신으로, 고속도로 건설의 혜택을 입음

> **오늘 주제: 단순한 좋은 경로가 아닌, "가장 짧은 경로(the very shortest path)"를 찾는 방법**

---

## 🧭 **탐색은 지도 문제가 아니다 (Search is not about Maps)**

* 탐색은 **지도(Map)** 문제가 아니라 **선택(Choice)** 문제임
* 수업 예시는 이해를 돕기 위해 시각적인 **지도 기반 예시**를 사용하지만 본질은 "선택"

> 질문: 탐색(Search)은 지도에 관한 것인가요?
> 답변: 아니요. 선택(Choice)에 관한 것입니다.

---

## 📏 **휴리스틱 거리(Heuristic Distance) 개념 복습**

* \*\*직선 거리(as the crow flies)\*\*를 의미함
* 도로가 없더라도 공중 거리 기준으로 목표와의 상대적 근접성 추정
* 일반적으로 가까울수록 좋지만, **예외(Dead end)** 존재

> 예: 노드 E는 목표(G)에 가까워 보여도 실제론 막다른 길 (잘못된 선택)

* **Hill Climbing / Beam Search**에서도 동일하게 직선 거리를 기준으로 다음 노드를 선택

---

## 🧪 **교실 예제를 통한 최단 경로 탐색 시뮬레이션**

### 🎯 Oracle 사용 예시

* 주어진 경로 중 Juana가 말한 최단 경로: `S → A → D → G`, 거리 11
* **Oracle 검증 방식**: 다른 모든 경로의 거리를 계산하여 Juana의 경로보다 짧은 것이 있는지 확인

### 🧠 Branch-and-Bound 알고리즘 (기본형)

1. 항상 현재까지 누적 거리(`g(n)`)가 가장 짧은 경로를 확장
2. 목적지(G)에 도달한 뒤에도 **다른 경로의 거리와 비교하여 검증 필요**

> 목적지에 도달했다고 즉시 종료하면 안 됨 → 더 짧은 경로가 남아있을 수 있음

### 🔄 알고리즘 흐름

1. S에서 A 또는 B로 이동 가능 → 각각 3, 5
2. 가장 짧은 A(3) 확장 → A→D(3): 6, A→B(4): 7
3. 가장 짧은 D(6) 확장 → D→G(5): 11 (Juana 경로와 동일)
4. 여전히 다른 경로들이 더 짧을 가능성 있어 계속 진행
5. B→A(4): 9, B→C(4): 9 → A→B→C(4): 11
6. 이후 C→E(6): 15 등 확인 → 더 짧은 경로 없음 → **Juana 검증 완료**

---

## 🧾 **Extended List의 필요성 (중복 확장 방지)**

* "N queued"와 "Extended"는 다름

  * **N queued**: 큐에 들어간 적이 있는 노드 추적 (중복 가능)
  * **Extended**: 실제로 확장한 노드 → **같은 노드를 더 긴 경로로 확장하지 않도록 방지**

### 📉 성능 향상 예시

* 이전 Branch-and-Bound에서 확장한 경로 수: `835`
* Extended List 추가 후 확장 경로 수: `38`

> **Dead Horse Principle**: 이미 더 짧은 경로로 도달한 노드는 더 이상 확장하지 않음 → "죽은 말은 더 몰지 않는다"

---

## ✈️ **Admissible Heuristic (허용 가능한 휴리스틱)**

* 정의:

  $$
  h(x) \leq h^*(x)  \quad \text{(실제 거리보다 작거나 같은 경우)}
  $$
* 휴리스틱이 실제 거리보다 과대 추정되지 않도록 보장

### 📌 적용 예시:

* S→A: 3, A→G (직선 거리): 7+ → 총 10+
* S→B: 5, B→G (직선 거리): 6 → 총 11
* 둘 다 11점으로 동일 → \*\*문자 순서(B < D)\*\*에 따라 B 먼저 확장

> Tie-break 시 Lexical Order 사용

---

## 🌟 **A* 알고리즘 (A-star Algorithm)*\*

> A\* = Branch-and-Bound + Extended List + Admissible Heuristic

### ⚙️ 구조 및 동작 방식

* 각 경로 평가 기준:

  $$
  f(n) = g(n) + h(n)
  $$
* g(n): 시작점부터 현재까지의 누적 거리
* h(n): 현재 노드부터 목표까지의 휴리스틱 추정 거리

### 📊 비교 결과:

| 알고리즘 종류               | 확장 경로 수 |
| --------------------- | ------- |
| Branch-and-Bound      | 835     |
| Extended List만        | 38      |
| Admissible Heuristic만 | 70      |
| A\* (둘 다 사용)          | **27**  |

> 문제 구조에 따라 어떤 방식이 더 효율적일지 달라짐

---

## 🧨 **Admissibility의 함정과 Consistency(일관성)의 필요성**

### ❗ 비유클리드 구조 예시:

그래프 구조:

```
      A      B
     /        \
S            C → G
```

거리:

* S→A: 1, A→C: 1, C→G: 10
* S→B: 1, B→C: 1

휴리스틱:

* h(A) = 100 (과대 추정), h(B) = 0, h(C) = 0

### 🚫 결과:

* A\*는 S→B→C→G를 선택하지 않고, S→A→C→G만 탐색하여 **최단 경로를 놓침**

> 이 구조는 \*\*지도 기반(Euclidean)\*\*이 아니므로 Admissible만으로는 부족

### ✅ Consistent Heuristic 필요 조건:

$$
|h(x) - h(y)| \leq \text{cost}(x, y)
$$

* 휴리스틱 간 차이가 이동 거리보다 작거나 같아야 함
* 예시에서 h(A)=100, h(C)=0 → 차이 100 > cost(2) → **불일치**

---

## 🧠 **최종 요약 및 교훈**

* 탐색(Search)은 지도보다 선택(Choice)의 문제
* 최단 경로 탐색은 다양한 탐색 기법 조합으로 성능을 향상 가능
* A\* 알고리즘은 다음 세 가지 요소가 결합된 최적 알고리즘:

  1. **Branch-and-Bound** (최단 누적 경로만 확장)
  2. **Extended List** (중복 확장 방지)
  3. **Admissible + Consistent Heuristic** (최적 해 보장)

> 📍 현대의 내비게이션 시스템도 이러한 A\* 알고리즘의 원리를 기반으로 동작함
